;===============================================;===============================================;;; PWConstraints by Mikael Laurson (c), 1995;===============================================;===============================================(in-package :omcs);===============================================;(defparameter *SC-data-file* "PWConstraints:PC-set-theory;SCs-data.lisp")(defparameter *SC-data-file* (namestring                              (make-pathname :directory (pathname-directory *load-pathname*)                                             :name "SCs-data.lisp")))#|;===============================================; create data-PCS-file;===============================================(defparameter *all-sets*(let ((all-subsets (remove nil (all-subsets '(0 1 2 3 4 5 6 7 8 9 10 11))))      (res (list (list () '(0-1 0)))))  (dolist (set all-subsets)    (push (list set (pcs::set-name+off-from-points set)) res)) res));(length *all-sets*);(find '(0 1 4 6 8 9) *all-sets* :key #'first :test #'equal);(find '(6-31b 0) *all-sets* :key #'second :test #'equal)(progn  (setf *print-pretty* nil)    (with-open-file (out *SC-data-file* :direction :output :if-exists :supersede)      (prin1 `',*all-sets* out))    (in-package :cl-user)  (setf *print-pretty* t))|#(defvar *all-possible-chroma-subsets-hash* (make-hash-table :test #'equal))(defun fill-possible-chroma-subsets-hash ()  (let (sets-list)     (with-open-file (in *SC-data-file* :direction :input)      (setq sets-list (eval (read in))))    ;(in-package :cl-user)    (clrhash *all-possible-chroma-subsets-hash*)    (dolist (set sets-list)       (setf (gethash (first set) *all-possible-chroma-subsets-hash*)              (second set)))    (dolist (set sets-list)       (when (zerop (second (second set)))      (setf (get  (first (second set)) :prime) (first set))))))  (fill-possible-chroma-subsets-hash);===========================;===========================(om::defmethod omcs::prime (SC)  :initvals '('0-1)  :indoc '("SC")  :icon 403  :doc "returns the prime form of SC"  (read-key SC :prime));(time (om::repeat-n (prime '4-17) 10000));(prime '0-1);==============(defun calc-6vect (SC)  (let ((res (make-list 6 :initial-element 0))        (prime (prime SC))        temp int ref)    (om::while (cdr prime)      (setq ref (pop prime))      (setq temp prime)      (om::while temp        (setq int (- (first temp) ref))        (when (> int 6) (setq int (- 12 int)))        (setf (nth (1- int) res) (1+ (nth (1- int) res)))        (pop temp)))    res));(calc-6vect '3-1) ;(calc-6vect '0-1)           (defun store-SC-icvectors ()  (dolist (SCs *all-SC-names*)    (dolist (SC SCs)      (setf (get SC :icv) (calc-6vect SC)))))(store-SC-icvectors);==============(om::defmethod! omcs::card ((SC t))  :initvals '('4-1)  :indoc '("SC")  :icon 403  :doc "returns the cardinality of SC"  (length (read-key SC :prime)));(time (repeat 10000 (card '12-1)))(om::defmethod omcs::ICV (SC)  :initvals '('4-1)  :indoc '("SC")  :icon 403  :doc "returns the interval-class vector (ICV) of SC"  (read-key SC :icv));(time (repeat 10000 (ICV '4-17)));===========================;===========================(defun make-set (l)  (let (lst)    (om::while l (push (mod (pop l) 12) lst))    (sort (delete-duplicates  lst) #'<)))(defun SC-name-from-points (midis)  (car (gethash  (make-set midis) *all-possible-chroma-subsets-hash*)))(defun SC-name-from-pcs (pcs)"pcs has to be a list of  pitch classes (only numbers from 0 to 11)and should not include duplicates !!!"  (car (gethash (sort (copy-list pcs) #'<) *all-possible-chroma-subsets-hash*)))(defun SC-name+off-from-points (midis)  (gethash  (make-set midis) *all-possible-chroma-subsets-hash*))(defun SC-name+off-from-pcs (pcs)  (gethash  (sort (copy-list pcs) #'<) *all-possible-chroma-subsets-hash*))(om::defmethod! omcs::SC-name ((midis list))   :initvals '('(1 2))  :indoc '("midis")  :icon 403  :doc "returns the SC-name of midis (a list of midi-values),midis can also be a list of lists of midis in which case SC-name returns the SC-names for each midi-value sublist"  (if (atom (car midis))    (car (gethash  (make-set midis) *all-possible-chroma-subsets-hash*))    (let (res)      (dolist (midis-l midis)        (push (car (gethash  (make-set midis-l) *all-possible-chroma-subsets-hash*)) res))      (nreverse res))));(SC-name '(62 66 69))(om::defmethod! omcs::SC+off ((midis list))   :initvals '('(1 2))  :indoc '("midis")  :icon 403  :doc  "returns a list containing the SC-name and the offset (i.e. the transposition relative to the prime form of the SC)of midis (a list of midi-values),midis can also be a list of lists of midis in which case SC+off returns the SCs with offsets for each midi-value sublist"  (if (atom (car midis))    (gethash  (make-set midis) *all-possible-chroma-subsets-hash*)    (let (res)      (dolist (midis-l midis)        (push (gethash  (make-set midis-l) *all-possible-chroma-subsets-hash*) res))      (nreverse res))));(SC+off '(62 66 69));(SC+off '((62 66 69) (61 66 69)));===========================; subsets(defun indexi (x y fn)  (cond ((null x) y)          (t (funcall fn                 (car x)                 (indexi (cdr x) y fn)))))(defun all-subsets (x)  (cond ((null x) (list ()))        (t (indexi            (all-subsets (cdr x))            nil            (function (lambda (u v)                        (cons (cons (car x) u)                              (cons u v))))))));(all-subsets '(a b c))(om::defmethod! omcs::all-subs ((SCs t))  :initvals '('4-1)  :indoc '("SCs")  :icon 403  :doc "returns all subset classes of SCs (a single SC or a list of SCs)" (if (atom SCs)    (remove-duplicates (mapcar #'(lambda (set) (SC-name-from-pcs set)) (all-subsets (prime SCs))))     (remove-duplicates      (apply #'append             (mapcar #'(lambda (SC)                         (remove-duplicates (mapcar #'(lambda (set) (SC-name-from-pcs set))                                                    (all-subsets (prime SC)))))                    SCs)))));(time (all-subs '6-z6)) ;(time (all-subs '10-1)) ;(time (all-subs '8-1)) ;(time (intersection card4 (all-subs '6-z6))) ;(time (intersection card4 (all-subs '8-6))) ;(time (intersection card6 (all-subs '10-1))) ;(time (all-subs '(6-z3a 6-5a 6-5b 6-z6 6-z11b 6-z12a 6-z12b 6-z17a 6-z17b 6-18a 6-18b 6-z36a 6-z38 6-z41a 6-z41b 6-z43a 6-z43b)))#|(defun store-SC-all-subs ()  (dolist (SCs *all-SC-names*)    (dolist (SC SCs)      (all-subs SC))));      (setf (get SC :all-subs) (all-subs SC))))); too slow (109.628 seconds);(time (store-SC-all-subs)) |#;===========================(om::defmethod omcs::subsets (SC card)  :initvals '('8-6 4)  :indoc '("SC" "card")  :icon 403  :doc "returns all subset classes of cardinality card of SC"  (remove-duplicates   (mapcar #'SC-name-from-pcs           (PMC (make-list card :initial-element (prime SC))                '((* ?1 ?2 (?if (< ?1 ?2)))                  (* ?1 ?2 (?if (not (member ?2 (rest rl))))))                :sols-mode :all))));(time (subsets '8-6 4)) ;(time (subsets '6-z3a 4)) (om::defmethod omcs::supersets (SC card)  :initvals '('4-z15a 9)  :indoc '("SC" "card")  :icon 403  :doc "returns all superset classes of cardinality card of SC" (let* ((prime (prime SC))        (set-diff (nreverse (set-difference '(0 1 2 3 4 5 6 7 8 9 10 11) prime)))        (s-space (make-list (- card (card SC)) :initial-element set-diff)))  (remove-duplicates   (mapcar #'(lambda (l) (SC-name-from-pcs (append prime l)))            (PMC s-space                '((* ?1 ?2 (?if (< ?1 ?2)))                  (* ?1 ?2 (?if (not (member ?2 (rest rl))))))                :sols-mode :all)))));(time (supersets '4-z15a 9)) (om::defmethod! omcs::sub/supersets ((SC t) (card number))  :initvals '('4-z15a 9)  :indoc '("SC" "card")  :icon 403  :doc "returns all subset classes of SC (when card is less than the cardinality of SC)or superset classes (when card is greater than the cardinality of SC) of cardinality card."  (if (= (card SC) card)    SC    (if (> (card SC) card)      (subsets SC card)      (supersets SC card))));(sub/supersets '4-z15a 9);(sub/supersets '4-z15a 2)#|; for testing(defun normal-order (SC) (let (set)  (maphash      #'(lambda (key data)        (when (and (eq (first data) SC) (= (second data) 0))          (setq set key)))   *all-possible-chroma-subsets-hash*)  set)) (defun test-setns () (let ((lst (all-subsets '(0 1 2 3 4 5 6 7 8 9 10 11)))       (fl t))  (while (and fl lst)   (when (car lst)    (when (not (eq (first (gethash (car lst) *all-possible-chroma-subsets-hash*))                   (pcs::set-name-from-points (car lst))))       (setq fl nil)))     (pop lst))  fl));(test-setns)  (defun test-primes () (let (false)  (dolist (SCs *all-SC-names*)    (dolist (SC SCs)      (unless (equal (pcs::prime (symbol-value SC)) (get SC :prime))        (print (list SC (pcs::prime (symbol-value SC)) (get SC :prime)))        (push SC false))))  false));(test-primes)(defun test-icvs () (let (false)  (dolist (SCs *all-SC-names*)    (dolist (SC SCs)      (unless (equal (coerce (pcs::icv (symbol-value SC)) 'list) (get SC :icv))        (print (list SC (coerce (pcs::icv (symbol-value SC)) 'list) (get SC :icv)))        (push SC false))))  false));(test-icvs)(defun eq-lists (l1 l2) (let (c)  (while (and l1 l2)    (setq c (car l1))    (setq l1 (remove c l1))    (setq l2 (remove c l2)))  (list l1 l2)))|#(defun eq-set (setnames &rest notes)"setnames can be SC or list of SC's, notes can be midis or a list of midis"  (setq setnames (om::list! setnames))  (when (listp (car notes)) (setq notes (car notes)))  (member (SC-name-from-points notes)  setnames))(defun eq-SC? (set-classes &rest midis)"checks whether the SC identity of midis (a list of midi-values) is foundin set-classes (a list of SC-names).set-classes can be a single SC or list of SCs, midis individual midi-valuesor a list of midis."  (setq set-classes (om::list! set-classes))   (when (listp (car midis)) (setq midis (car midis)))   (member (SC-name-from-points midis)  set-classes));(eq-SC? '(3-11a 3-11b) 60 64 67));(eq-SC? '(3-11a 3-11b) '(60 64 67))